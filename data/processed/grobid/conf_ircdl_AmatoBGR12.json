{"bibliography":{"title":"Quick and Easy Implementation of Approximate Similarity Search with Lucene","authors":[{"person_name":{"surname":"Amato","first_name":"Giuseppe"},"affiliations":[{"department":null,"institution":"ISTI -CNR","laboratory":null}],"email":"giuseppe.amato@isti.cnr.it"},{"person_name":{"surname":"Bolettieri","first_name":"Paolo"},"affiliations":[{"department":null,"institution":"ISTI -CNR","laboratory":null}],"email":"paolo.bolettieri@isti.cnr.it"},{"person_name":{"surname":"Gennaro","first_name":"Claudio"},"affiliations":[{"department":null,"institution":"ISTI -CNR","laboratory":null}],"email":"claudio.gennaro@isti.cnr.it"},{"person_name":{"surname":"Rabitti","first_name":"Fausto"},"affiliations":[{"department":null,"institution":"ISTI -CNR","laboratory":null}],"email":"fausto.rabitti@isti.cnr.it"}],"date":null,"ids":null,"target":null,"publisher":null,"journal":null,"series":null,"scope":null},"keywords":[],"citations":{"b0":{"title":"Approximate similarity search in metric spaces using inverted files","authors":[{"person_name":{"surname":"Amato","first_name":"G"},"affiliations":[],"email":null},{"person_name":{"surname":"Savino","first_name":"P"},"affiliations":[],"email":null}],"date":{"year":"2008","month":null,"day":null},"ids":null,"target":null,"publisher":"ICST","journal":null,"series":null,"scope":{"volume":null,"pages":{"from_page":1,"to_page":10}}},"b1":{"title":"Cophir image collection under the microscope","authors":[{"person_name":{"surname":"Batko","first_name":"M"},"affiliations":[],"email":null},{"person_name":{"surname":"Kohoutkova","first_name":"P"},"affiliations":[],"email":null},{"person_name":{"surname":"Novak","first_name":"D"},"affiliations":[],"email":null}],"date":{"year":"2009","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":null,"series":null,"scope":{"volume":null,"pages":{"from_page":47,"to_page":54}}},"b2":{"title":"Enabling content-based image retrieval in very large digital libraries","authors":[{"person_name":{"surname":"Bolettieri","first_name":"P"},"affiliations":[],"email":null},{"person_name":{"surname":"Esuli","first_name":"A"},"affiliations":[],"email":null},{"person_name":{"surname":"Falchi","first_name":"F"},"affiliations":[],"email":null},{"person_name":{"surname":"Lucchese","first_name":"C"},"affiliations":[],"email":null},{"person_name":{"surname":"Perego","first_name":"R"},"affiliations":[],"email":null},{"person_name":{"surname":"Rabitti","first_name":"F"},"affiliations":[],"email":null}],"date":{"year":"2009","month":null,"day":null},"ids":null,"target":null,"publisher":"DELOS","journal":null,"series":null,"scope":{"volume":null,"pages":{"from_page":43,"to_page":50}}},"b3":{"title":"Effective proximity retrieval by ordering permutations","authors":[{"person_name":{"surname":"Chavez","first_name":"E"},"affiliations":[],"email":null},{"person_name":{"surname":"Figueroa","first_name":"K"},"affiliations":[],"email":null},{"person_name":{"surname":"Navarro","first_name":"G"},"affiliations":[],"email":null}],"date":{"year":"2007","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":"IEEE Transactions on Pattern Analysis and Machine Intelligence","series":null,"scope":{"volume":30,"pages":{"from_page":1647,"to_page":1658}}},"b4":{"title":"Pp-index: Using permutation prefixes for efficient and scalable approximate similarity search","authors":[{"person_name":{"surname":"Esuli","first_name":"A"},"affiliations":[],"email":null}],"date":{"year":"2009","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":null,"series":null,"scope":{"volume":null,"pages":{"from_page":17,"to_page":24}}},"b5":{"title":"Use of permutation prefixes for efficient and scalable approximate similarity search","authors":[{"person_name":{"surname":"Esuli","first_name":"A"},"affiliations":[],"email":null}],"date":{"year":"2011","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":"Information Processing & Management","series":null,"scope":null},"b6":{"title":"Comparing top-k lists","authors":[{"person_name":{"surname":"Fagin","first_name":"R"},"affiliations":[],"email":null},{"person_name":{"surname":"Kumar","first_name":"R"},"affiliations":[],"email":null},{"person_name":{"surname":"Sivakumar","first_name":"D"},"affiliations":[],"email":null}],"date":{"year":"2003","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":"SIAM J. of Discrete Math","series":null,"scope":{"volume":17,"pages":{"from_page":134,"to_page":160}}}},"sections":[{"title":"Introduction","paragraphs":[{"text":"Very often multimedia content is not associated with any text or metadata, therefore traditional search techniques cannot be used and content-based retrieval or similarity-based retrieval is the only way to access this information. Moreover, even when textual information is available, the combination of similarity search with the full-text search is very useful.","refs":[]},{"text":"However, if the digital data we want to search for similarity are just a few thousand, a sequential search could be enough. But when the amount of data becomes large (hundreds of thousands), a single similarity search can last minutes.","refs":[]},{"text":"On the other hand, the continuous price reduction of digital production tools, such as cameras, camcorders, and smartphones, is driving the demand for contentbased retrieval tools.","refs":[]},{"text":"Several attempts are currently being made to provide these capabilities, for instance Google images allows the user to upload a photo to find out similar images in the web. However, the cost of developing and deploying from scratch a robust and reliable system with content-based image retrieval facilities could not be within the range of possibilities for everyone.","refs":[]},{"text":"But how easy is it to add these features to an existing Digital Library Management System? In this paper, we would like to approach the problem of similarity search by enhancing the full-text retrieval library Lucene1 with content-based image retrieval facilities. Apache Lucene is a high-performance, full-featured text search engine library written entirely in Java that is suitable for nearly any application requiring full-text search abilities.","refs":[{"start":216,"end":217,"marker":null,"target":"#foot_0"}]},{"text":"In particular, we use a technique for approximate similarity search when data are represented in generic metric spaces. The metric space approach to similarity search requires the similarity between objects of a database to be measured by means of a distance (dissimilarity) function, which satisfies the metric postulates: positivity, symmetry, identity, and triangle inequality. The advantage of the metric space approach to the data searching is its \"extensibility\", allowing us to potentially work for a large number of existing proximity measures as well as many others to be defined in the future. In contrast, many approaches need objects to be represented as vectors and cannot be applied to generic metric spaces.","refs":[]},{"text":"The basic idea exploited in our approach has been independently introduced by Amato et al [1] and Chavez et al. [4] and consists on observing that two objects x 1 and x 2 are very similar (which in metric spaces means that they are close one to each other), if their view of the surrounding world (their perspective) is similar as well. This implies that, if we take a set of objects from the database and we order them according to their similarity to x 1 and x 2 , the obtained orderings are also similar. Therefore, we can approximatively judge the similarity between any two arbitrary objects x 1 and x 2 , by comparing the ordering, according to their similarity to x 1 and x 2 , of a group of reference objects, instead of using the actual distance function between the two objects.","refs":[{"start":90,"end":93,"marker":"bibr","target":"#b0"},{"start":112,"end":115,"marker":"bibr","target":"#b3"}]},{"text":"Clearly, it is possible to find some special examples where very similar (or even identical) orderings correspond to very dissimilar objects. For instance, if reference points are all positioned on a line, two objects that are positioned on another line orthogonal to the first one will produce the same ordering of the reference points, independently of their actual position. However, as it has been proved in [1], even with a random selection of the reference points, the accuracy of this approach is very good.","refs":[{"start":412,"end":415,"marker":"bibr","target":"#b0"}]},{"text":"Capitalizing on the work of Amato et al [1], we also use the inverted files in our research. Another similar approach, called PP-Index [5,6], uses a compact prefix tree for estimating the real distance order of the indexed objects with respect to a query. All these above mentioned approaches make use of index methods completely designed and developed from scratch. Although the results of these systems are quite impressive2 , they probably will not easily move from research prototypes to commercial applications due to the strong effort required to maintain and support such information systems. Consider, for example, Lucene: at the time of this writing, Lucene's core team includes about half a dozen active developers. In addition to the official project developers, Lucene has a fairly large and active technical user community that frequently contributes patches, bug fixes, and new features. Moreover, only the approach in [5] provides a full-text search on descriptive textual metadata, which is, however, not combined with the content-based similarity search. Our approach instead since it is built on top of Lucene provides complex query processing by combining similarity search with the full-text search.","refs":[{"start":40,"end":43,"marker":"bibr","target":"#b0"},{"start":135,"end":138,"marker":"bibr","target":"#b4"},{"start":138,"end":140,"marker":"bibr","target":"#b5"},{"start":425,"end":426,"marker":null,"target":"#foot_1"},{"start":933,"end":936,"marker":"bibr","target":"#b4"}]},{"text":"The structure of the paper is as follows. Section 2 formalizes the idea of searching by using the perspective of the objects and shows how this idea can be efficiently supported by the use of the Lucene library. Section 3 proposes a preliminary performance evaluation of the proposed solution.","refs":[]}]},{"title":"Perspective Based Space Transformation","paragraphs":[{"text":"Let D be a domain of objects and d : D × D → R be a metric distance function between objects of D. Let R ∈ D m , be a vector of m reference objects chosen from D.","refs":[]},{"text":"Given an object x ∈ D, we represent it as the ordering of the reference objects R according to their distance d from x. More formally, an object x ∈ D is represented with O(x), where O(x) is the vector of ranks of all objects of R, ordered according to their distance d from x.","refs":[]},{"text":"We denote the rank in O(x) of a reference object r i ∈ R as O i (x). For example, if O 4 (x) = 3, r 4 is the 3rd nearest object to x among those in R.","refs":[]},{"text":"Figure 1 exemplifies the transformation process. Figure 1a) sketches a number of reference objects (black points), data objects (white points), and a query object (gray point). Figure 1b) shows the encoding of the data objects in the transformed space. We will use this as a running example throughout the remainder of the paper.","refs":[{"start":7,"end":8,"marker":"figure","target":"#fig_0"},{"start":56,"end":58,"marker":"figure","target":"#fig_0"},{"start":184,"end":186,"marker":"figure","target":"#fig_0"}]},{"text":"As we anticipated before, we assume that if two objects are very close one to each other, they have a similar view of the space. This means that also the orderings of the reference objects according to their distance from the two objects should be similar. There are several standard methods for comparing two ordered lists, such as as Kendall's tau, the Spearman Footrule Distance, and the Spearman Rho Distance [7]. In this paper, we concentrate our attention on the latter distance, which is also used in [4]. The reason of this choice (explained later on) is tied to the way standard search engines process the similarity between documents and query. Given two ordered lists O(x) and O(q) (x, q ∈ D), containing the ranks of all objects of R, the Spearman Rho Distance d ρ between O(x) and O(q) is computed as in the following:","refs":[{"start":413,"end":416,"marker":"bibr","target":"#b6"},{"start":508,"end":511,"marker":"bibr","target":"#b3"}]},{"text":"where m is the dimension of the vector R. This distance measures the degree in which rankings correspond with each other and it can be used in place of the metric distance d (see Figure 1c)).","refs":[{"start":186,"end":188,"marker":"figure","target":"#fig_0"}]},{"text":"In order to reduce the search cost and also, as we will see, the size of the index, it is convenient to take just the closest reference objects to represent any object that has to be indexed. Let k x ≤ m be the number of reference objects used for representing the objects. Note that, in this case, different objects will be typically represented by different reference objects, given that different objects will have different neighbor reference objects. This idea can be extended also to the query, for which we can exploit a number k q ≤ k x of nearest reference objects. If we define two approximate version of the vectors O k , such that O k i (x) = k + 1 for all i such that O i (x) > k (with either k = k x or k = k q ), we can still use the distance in Eq. (1), i.e:","refs":[]},{"text":"In this case, we assume that x belongs to the dataset and q is the query. This is a generalization of the Spearman Rho Distance with location parameter for the special case l = k x = k q [7], which evaluates the distance (or dissimilarity) of two top-k ranked lists.","refs":[{"start":187,"end":190,"marker":"bibr","target":"#b6"}]},{"text":"Up to now, we have discussed how to compare two partial rankings of reference objects corresponding to objects and query. However, we did not say how to implement the proposed idea into a standard full-text search engine.","refs":[]},{"text":"Most text search engine, including Lucene, use the Vector Space model to represent text. In this representation, a text document is represented as a vector of terms each associated with the number of occurrences of the term in the document. Therefore, we have to define a textual representation each metric object of the database so that the inverted index produced by Lucene looks like the one presented above and that its built-in similarity function behaves like the Spearman Similarity rank correlation used to compare ordered lists. This can be achieved in several ways, in the following we outline our solution.","refs":[]},{"text":"First, we associate each element r i ∈ R with a unique alphanumeric keyword τ i . Then we use the function t k (x), defined in the following, to obtain a spaceseparated concatenation of zero or more repetitions of τ i words:","refs":[]},{"text":"where, by abuse of notation, we denote the space-separated concatenation of words with the union operator . The function t k (x) returns a text representation of x such that, if r i appears in position p in the list of the k reference objects nearest to x, then the term τ i is repeated (k + 1)p times in the text. The function t k (x) is used to generate the textual representation of the object x to be used for both indexing and querying purposes. Specifically, we use k = k x for indexing and k = k q for querying.","refs":[]},{"text":"In our case, this means that, if for instance term τ i corresponding to the reference descriptor r i (1 ≤ i ≤ m) appears n times, the i-th element of the vector will contain the number n, and whenever τ i does not appear it will contain 0. To summarize, we finally get the vectors of size m, O kx (x) and O kq (q), which correspond to t kx (x) and t kq (q), respectively. The cosine similarity is typically adopted to determine the similarity of the query vector and a vector in the database of the text search engine, and it is defined as:","refs":[]},{"text":"where * is the scalar product. sim cos can be used as a function that evaluates the similarity of the two ranked lists in the same way as d ρ (x, q) defined in Eq. ( 2) does (although it is defined as a distance), and it is possible to prove that the first one is an order reversing monotonic transformation of the second one, and then that they are equivalent for practical aspects 3 . This means that if we use d ρ ( O kx (x), O kq (q)) and we take the first k nearest metric objects from dataset (i.e, from the shortest distance to the highest) we obtain exactly the same descriptors in the same order if we use sim cos ( O kx (x), Q kq (q)) and take the first k similar objects (i.e., the greater values to the smaller ones). This is illustrated in Figure 1c). The proof of this proposition is omitted due to space limitations of this paper but may be demonstrated using simple mathematical steps. To have an idea on how these textual representations look like, consider the example reported in Figure 1, and let us assume τ 1 = RO1, τ 2 = RO2, etc. The function t will generate the following output","refs":[{"start":166,"end":167,"marker":"formula","target":"#formula_1"},{"start":383,"end":384,"marker":null,"target":"#foot_2"},{"start":760,"end":762,"marker":"figure","target":"#fig_0"},{"start":1006,"end":1007,"marker":"figure","target":"#fig_0"}]},{"text":"and for the query q:","refs":[]},{"text":"If we exploit the idea of taking just the closest reference objects to represent any object that has to be indexed, and assuming, for instance, k x = 3 (the number of reference objects used for indexing), and k q = 2 (the number of reference objects used for generating the query), the textual representations become:","refs":[]},{"text":"and for the query q:","refs":[]},{"text":"This representation of an object will be clearly smaller than using all reference objects. In addition, this has also the effect of reducing the size of the inverted file. In fact, every object will be just inserted into k x posting lists, by reducing their size and by also reducing the search cost.","refs":[]}]},{"title":"Reordering Search Result","paragraphs":[{"text":"The algorithms described so far use an object representation in a transformed space and an object similarity measure based on a variation of the d ρ measure to order the objects in the dataset in decreasing similarity with respect to the query. The result is an approximation of the exact result set that would have been obtained if the ordering of the objects was performed using the original distance d in the original data space. Suppose we are searching for the k most similar (nearest neighbors) objects to the query. We can improve the quality of the approximation by re-ranking, using the original distance function d, the first c (c ≥ k) objects from the approximate result set at the cost of c more disk accesses and c distance computations. We will show that this technique significantly improves the accuracy, though only requiring a very low search cost. In fact, when c is much smaller than the size of the dataset, this extra cost can be considered negligible with respect to the cost of accessing the inverted file. For instance, when k is 10 and c = 1000, with a dataset size of 1,000,000 it means that we have to reorder a number of objects equivalent to just 0.1% of the entire dataset. Usually, as we will see in the experiments, this is not true for other access methods, for instance tree-based access methods, where the efficiency of the search algorithms strongly depends on the amount of objects retrieved.","refs":[]}]},{"title":"A Real Application and Performance Evaluation","paragraphs":[{"text":"In this section, we report the results of an experimental evaluation of the proposed method. For both testing and demonstration, we developed a web user interface to perform image content based retrieval on the CoPhIR dataset [3], which consists of 106 millions images, taken from Flickr (www.flickr.com), described by MPEG-7 visual descriptors. Content based retrieval can be performed by using similarity functions of the visual descriptors associated with the images.","refs":[{"start":226,"end":229,"marker":"bibr","target":"#b2"}]},{"text":"We have indexed the whole CoPhIR dataset and for each image, we created five Lucene fields which can be queried separately or in combination. The first field contains the unique identifier of the Flickr image. The second field maintains the textual information taken from title, and tags of the original Flickr image. The other three fields contain the content generated by the t function explained above for searching on three different pre-combined visual features. In particular, in order to support content based search, the CoPhIR project extracted several MPEG-7 visual descriptors from each image, three descriptors for describing the colors (SCD, CSD, and CLD) and two for describing textures (EHD and HTD). We have indexed three different aggregations of those descriptors, the first one combining the three color descriptors, the second one combining the two texture descriptors, and the third one combining all five descriptors. In this way we leave the possibility to the user to search for colors and textures independently or to search all the descriptors together. The weights used for aggregating the descriptors are the ones suggested in [2].","refs":[{"start":1155,"end":1158,"marker":"bibr","target":"#b1"}]},{"text":"At the address http://lucignolo.isti.cnr.it/ a demo web application of the developed search engine can be found. From that page it is possible to perform a full-text search, a similarity search starting from one of the random selected images. Besides the three types of visual similarities, thanks to the search functionality of Lucene, it also provides complex query processing by combining any of the three types of similarity search with the full-text search on descriptive metadata.","refs":[]},{"text":"We conducted our experiments using the combination of all visual descriptors, with 20,000 reference objects and by setting k x = 50 during the indexing. We used the measure of the recall to assess the accuracy of the method. Specifically, given a query object q, the recall is defined as","refs":[]},{"text":", where S and S A are the ordering of the k closest objects to q found respectively by the exact similarity and by the proposed method. In practice, we compare the efficacy of our solution with an algorithm that exploits a sequential scan of the whole database. The comparison was made at the same conditions, using only the similarity obtained as combination of all five MPEG-7 descriptors, without exploiting the textual content. For this purpose 100 queries were randomly selected from the database. Results are shown in Figure 2. The graphs show the recall varying the number of items retrieved k for various options of the k q ≤ k. The graph on the left shows the recall of the basic implementation without reordering. The graph on the right shows the performance of the recall when the reordering strategy is used, with c = 2, 000.  Figure 3 (left graph) also shows the average query processing times as function of k q , with and without reordering. As expected, the search cost is worse when use the reordering strategy but still acceptable, also considering the big improvement in terms of recall.","refs":[{"start":531,"end":532,"marker":"figure","target":"#fig_1"},{"start":846,"end":847,"marker":"figure","target":"#fig_2"}]}]},{"title":"Comparison with PP-Index","paragraphs":[{"text":"A similar approach [6] (based on the on representing any indexed object with its view of the surrounding world), called Permutation Prefix Index (PP-Index), uses an index data structure that supports efficient approximate similarity search.","refs":[{"start":19,"end":22,"marker":"bibr","target":"#b5"}]},{"text":"Figure 3 (right graph) shows the comparison of the recall between our approach and PP-Index on the CoPhIR dataset. Actually, PP-Index exhibits better performance. However, as explained in the introduction, the aim of our approach is to provide a tool for rapid development and integration of a multimedia object retrieval system with other digital libraries based on text. As a result, along with the obvious advantage of having a system which relies upon an open source library that is constantly expanding, our method provides content based search combined with textual metadata.","refs":[{"start":7,"end":8,"marker":"figure","target":"#fig_2"}]}]},{"title":"Conclusions and Future Work","paragraphs":[{"text":"In this paper we presented an approach to approximate similarity search in metric spaces based on a space transformation that relies on the idea of perspective from a data point. We proved through a concrete implementation that the proposed approach has clear advantages over other methods existing in literature in terms of easiness in implementation. A major characteristic of the proposed technique is that it can be implemented by using inverted files, thus capitalizing on existing software investments.","refs":[]},{"text":"This approach can take advantage of parallelism of Lucene and easily scales up to any desired dataset size. This can be obtained by distributing the inverted index in multiple Lucene segment, and exploding parallel search facilities of Lucene. For instance, our index consists of ten separated Lucene indexes each one including about 1/10 of the whole dataset. If the indexes reside on different physical disks, we may obtain performance improvements; however, in our tests conducted with a single physical disk, the performance with multi-thread search was slightly better than with a single-thread search.","refs":[]}]}],"tables":{},"abstract":{"title":"Abstract","paragraphs":[{"text":"Similarity search technique has been proved to be an effective way for retrieving multimedia content. However, as the amount of available multimedia data increases, the cost of developing from scratch a robust and scalable system with content-based image retrieval facilities is quite prohibitive.","refs":[]},{"text":"In this paper, we propose to exploit an approach that allows us to convert low level features into a textual form. In this way, we are able to easily set up a retrieval system on top of the Lucene search engine library that combines full-text search with approximate similarity search capabilities.","refs":[]}]}}
{"bibliography":{"title":"Interactive Text Analysis and Information Extraction","authors":[{"person_name":{"surname":"Giannakopoulos","first_name":"Tasos"},"affiliations":[{"department":null,"institution":"University of Athens and Athena Research Center","laboratory":null}],"email":null},{"person_name":{"surname":"Foufoulas","first_name":"Yannis"},"affiliations":[{"department":null,"institution":"University of Athens and Athena Research Center","laboratory":null}],"email":null},{"person_name":{"surname":"Dimitropoulos","first_name":"Harry"},"affiliations":[{"department":null,"institution":"University of Athens and Athena Research Center","laboratory":null}],"email":null},{"person_name":{"surname":"Manola","first_name":"Natalia"},"affiliations":[{"department":null,"institution":"University of Athens and Athena Research Center","laboratory":null}],"email":null}],"date":null,"ids":{"DOI":"10.1007/978-3-030-11226-4_27","arXiv":null},"target":null,"publisher":null,"journal":null,"series":null,"scope":null},"keywords":[],"citations":{"b0":{"title":"Developing tightly-coupled data mining applications on a relational database system","authors":[{"person_name":{"surname":"Agrawal","first_name":"R"},"affiliations":[],"email":null},{"person_name":{"surname":"Shim","first_name":"K"},"affiliations":[],"email":null}],"date":{"year":"1996","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":null,"series":null,"scope":null},"b1":{"title":"","authors":[{"person_name":{"surname":"Stamatogiannakis","first_name":"Lefteris"},"affiliations":[],"email":null},{"person_name":{"surname":"Li Triantafillidi","first_name":"Mei"},"affiliations":[],"email":null},{"person_name":{"surname":"Foufoulas","first_name":"Yannis"},"affiliations":[],"email":null}],"date":{"year":"2018","month":"10","day":"04"},"ids":null,"target":"http://www.github.com/magdik/madIS","publisher":null,"journal":null,"series":null,"scope":null},"b2":{"title":"The hadoop distributed file system","authors":[{"person_name":{"surname":"Shvachko","first_name":"K"},"affiliations":[],"email":null},{"person_name":{"surname":"Kuang","first_name":"H"},"affiliations":[],"email":null},{"person_name":{"surname":"Radia","first_name":"S"},"affiliations":[],"email":null},{"person_name":{"surname":"Chansler","first_name":"R"},"affiliations":[],"email":null}],"date":{"year":"2010","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":null,"series":null,"scope":null},"b3":{"title":"A relational approach to complex dataflows","authors":[{"person_name":{"surname":"Chronis","first_name":"Y"},"affiliations":[],"email":null}],"date":{"year":"2016","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":null,"series":null,"scope":null},"b4":{"title":"Discovering and visualizing interdisciplinary content classes in scientific publications","authors":[{"person_name":{"surname":"Giannakopoulos","first_name":"T"},"affiliations":[],"email":null},{"person_name":{"surname":"Foufoulas","first_name":"I"},"affiliations":[],"email":null},{"person_name":{"surname":"Stamatogiannakis","first_name":"E"},"affiliations":[],"email":null},{"person_name":{"surname":"Dimitropoulos","first_name":"H"},"affiliations":[],"email":null},{"person_name":{"surname":"Manola","first_name":"N"},"affiliations":[],"email":null},{"person_name":{"surname":"Ioannidis","first_name":"Y"},"affiliations":[],"email":null}],"date":{"year":"2014","month":null,"day":null},"ids":null,"target":null,"publisher":null,"journal":"D-Lib Mag","series":null,"scope":{"volume":20,"pages":{"from_page":4,"to_page":4}}},"b5":{"title":"Visual-based classification of figures from scientific literature","authors":[{"person_name":{"surname":"Giannakopoulos","first_name":"T"},"affiliations":[],"email":null},{"person_name":{"surname":"Foufoulas","first_name":"I"},"affiliations":[],"email":null},{"person_name":{"surname":"Stamatogiannakis","first_name":"E"},"affiliations":[],"email":null},{"person_name":{"surname":"Dimitropoulos","first_name":"H"},"affiliations":[],"email":null},{"person_name":{"surname":"Manola","first_name":"N"},"affiliations":[],"email":null},{"person_name":{"surname":"Ioannidis","first_name":"Y"},"affiliations":[],"email":null}],"date":{"year":"2015","month":"05","day":null},"ids":null,"target":null,"publisher":"ACM","journal":null,"series":null,"scope":{"volume":null,"pages":{"from_page":1059,"to_page":1060}}},"b6":{"title":"Content visualization of scientific corpora using an extensible relational database implementation","authors":[{"person_name":{"surname":"Giannakopoulos","first_name":"T"},"affiliations":[],"email":null},{"person_name":{"surname":"Stamatogiannakis","first_name":"E"},"affiliations":[],"email":null},{"person_name":{"surname":"Foufoulas","first_name":"I"},"affiliations":[],"email":null},{"person_name":{"surname":"Dimitropoulos","first_name":"H"},"affiliations":[],"email":null},{"person_name":{"surname":"Manola","first_name":"N"},"affiliations":[],"email":null},{"person_name":{"surname":"Ioannidis","first_name":"Y"},"affiliations":[],"email":null}],"date":{"year":"2014","month":null,"day":null},"ids":{"DOI":"10.1007/978-3-319-08425-1_10","arXiv":null},"target":"https://doi.org/10.1007/978-3-319-08425-1","publisher":"Springer","journal":null,"series":null,"scope":{"volume":416,"pages":{"from_page":101,"to_page":112}}},"b7":{"title":"High-pass text filtering for citation matching","authors":[{"person_name":{"surname":"Foufoulas","first_name":"Y"},"affiliations":[],"email":null},{"person_name":{"surname":"Stamatogiannakis","first_name":"L"},"affiliations":[],"email":null},{"person_name":{"surname":"Dimitropoulos","first_name":"H"},"affiliations":[],"email":null},{"person_name":{"surname":"Ioannidis","first_name":"Y"},"affiliations":[],"email":null}],"date":{"year":"2017","month":null,"day":null},"ids":{"DOI":"10.1007/978-3-319-67008-9_28","arXiv":null},"target":"https://doi.org/10.1007/978-3-319-67008-928","publisher":"Springer","journal":null,"series":null,"scope":{"volume":10450,"pages":{"from_page":355,"to_page":366}}}},"sections":[{"title":"Introduction","paragraphs":[{"text":"Text mining of scientific publications is a very important task as it offers the tools for extracting useful information from their content that is of interest not only to researchers and research communities, but also to funders, publishers, policymakers, etc. This information 'enriches' publications and allows the interlinking of relevant content; a process critical for allowing researchers to discover, share and re-use scientific results in context, and research administrators to assess research impact and investment in a transparent and efficient way.","refs":[]},{"text":"In OpenAIRE 1 , we tackle the problem of linking publications to projects and/or communities that are members of OpenAIRE. By initiating bilateral collaborations with national funding agencies, research and infrastructure initiatives, OpenAIRE is able to serve them with the OpenAIRE mining services and research impact suite of services. OpenAIRE mining services can automatically infer links from publication full-texts to datasets, projects, software, and research initiatives. Today such services are manually configured, based on a model of the concepts to be discovered by mining and a set of mining rules. This is a difficult text mining task because each new community/funder requires a different approach, so we actually need to customize the mining rules and run an almost new mining algorithm for every new funder/community.","refs":[]},{"text":"Currently, an information extraction algorithm is developed following the steps below:","refs":[]},{"text":"-Communicate with a field expert and exchange some information or data -Produce an initial version of the algorithm -Run the current algorithm version on a large 'test' corpus of publication fulltexts -Send the results to the expert for validation -Update the algorithm using the experts' feedback.","refs":[]},{"text":"The last three steps are in fact an iterative procedure. The algorithm is finalised when the quality of its results is satisfying. Since, each mining task is unique and the produced algorithm differs, this may be a time consuming method with a lot of communication between experts and developers.","refs":[]},{"text":"In this paper, we provide the experts with an interactive mining platform which allows them to set up their mining rules, validate the intermediate results and update the rules accordingly. This platform covers the following requirements:","refs":[]},{"text":"-It is user friendly, since its users are not developers -It provides the users with enough configuration tools to produce their mining profiles -It creates and runs automatically the mining algorithms on sample data selected by the user -It supports reproducibility of the mining algorithms.","refs":[]},{"text":"The rest of the paper is organised as follows: First, we describe the configuration tools and how users are able to produce and tune a mining algorithm. Then, we present the user interface of the platform. We explain how users can evaluate a produced mining algorithm using sample datasets and we present the reproducibility features of the platform. Finally, we discuss in brief the future work.","refs":[]}]},{"title":"Configuration Tools","paragraphs":[{"text":"A complete set of configuration tools are available, so that users are able to produce and update their algorithms. These tools are divided in three main categories:","refs":[]},{"text":"-Preprocessing tools -Processing tools -Evaluation tools.","refs":[]},{"text":"Preprocessing tools are all the tools that a data miner uses during the preprocessing phase of a text mining procedure. Such tools are stemmers, tockenizers, normalizers, etc. During this step the user uploads the concepts that are to be mined. Each concept consists of a string (i.e., its name) and a set of n-grams/phrases that usually are used when an author mentions this concept.","refs":[]},{"text":"Processing tools include the main tools that a user utilises during the extraction phase. The algorithm runs a scrolling window over the text searching for matches. The user defines the length of this window. S/he also selects positive and negative weighted phrases. These phrases influence the confidence level of a match. Finally, the user selects the matching policy: when higher recall rates are prefered then the matching policy is more soft; otherwise the policy is strict.","refs":[]},{"text":"Evaluation tools include the tools that are required to calculate the precision of an algorithm. Users are able to run their algorithms on predefined datasets or define and upload their own datasets. Moreover, during a run they have access to a preview where the matching areas, the positive/negative phrases, and the actual matches are highlighted. This makes the validation/update process easier since users are able to tune the algorithm rules and view online the results of their updates, thus facilitating rapid algorithm development.","refs":[]}]},{"title":"User Interface","paragraphs":[{"text":"The user interface and its usability is very important since it provides the users with all the available tools to create the algorithm. In this section, we go through the portal and show how a user can produce algorithms, experiment himself, set his rules, etc.","refs":[]},{"text":"Users are landed in the home page of the interactive mining platform which is shown in Fig. 1. Here, the user is able to see the saved profiles or create new profiles. Some example profiles are already available so that users may use them to familiarize themselves with the platform.","refs":[{"start":92,"end":93,"marker":"figure","target":null}]},{"text":"Figures 2 and3 illustrate how the user uploads/edits his mining concepts. After selecting/creating a mining profile, users are able to configure their algorithm. The first step regards the addition/deletion of mining concepts. Users can either use the online form to edit their concepts or drag and drop a tabular file. For each concept users upload an identifying string and some phrases/n-grams that the authors often use to refer to this concept.","refs":[{"start":8,"end":9,"marker":"figure","target":null},{"start":13,"end":14,"marker":"figure","target":"#fig_1"}]},{"text":"Figure 4 presents the main configuration and experiment page of the portal. When the concepts are ready, users are able to configure their mining rules. They can define their mining strategy (choose between high recall or high precision), add positive/negative phrases/keywords, tune the preprocessing steps, and modify the length of the mining area size (i.e., the length of the text area before and after a match that the algorithm uses as context to decide if a match is a true positive or not).","refs":[{"start":7,"end":8,"marker":"figure","target":"#fig_2"}]},{"text":"Positive phrases are phrases or keywords that are very likely to be found in the vicinity of a match. Different weights can be used to specify the relative importance of the different phrases. Negative phrases are phrases that when  The preprocessing steps currently supported are stopword removal (removes common words such as articles like 'an', 'and', 'the', etc., and prepositions like 'after', 'to', etc.), punctuation removal, normalization (converting text to lower case), and word stemming (the process by which variant forms of a word are reduced to a common form, for example: connection, connections, connective, connected and connecting, are reduced to the stem 'connect').","refs":[]},{"text":"Moreover, users can test online their mining rules against the selected datasets. The mining results are presented using annotated and highlighted text. The users edit their rules and run experiments repeatedly until they get valid results.","refs":[]},{"text":"When users are satisfied with their mining rules they can continue to the last step of the mining configuration. Users can save their configuration for future use, as shown in Fig. 5.","refs":[{"start":181,"end":182,"marker":"figure","target":"#fig_3"}]},{"text":"When users return to the mining platform their profiles are available at their home page for further modifications and testing (Fig. 6).","refs":[{"start":133,"end":134,"marker":"figure","target":"#fig_4"}]}]},{"title":"Reproducibility Features","paragraphs":[{"text":"Since the purpose of the platform is to allow users to build and update their own mining algorithms, reproducibility features are highly important. Users should be able to revisit their algorithms, update their rules, and continue their experiments. To support this, a database file is stored for each user of the platform. The page is split into two main horizontal sections. The left section is where users define their mining rules and choose between high recall or high precision with a slider. Here they can add or edit their positive and negative phrases/keywords, define the preprocessing steps to be used, and advanced users can also define the length of the text mining area size. The right section is the test area where mining results are presented using annotated and highlighted text, allowing users to tune their rules and run experiments repeatedly until they get valid results.  This database contains all the saved algorithms per user. This list is shown to the users when they are connected to the portal. Users are able to select a profile and update it.","refs":[]},{"text":"Another important feature is that the platform also maintains the history of the saved changes. So, users may visit a previous version of their algorithm. This is a very important feature that allows users to compare different versions.","refs":[]}]},{"title":"Implementation Details","paragraphs":[{"text":"The mining platform is implemented using Python's Tornado Server2 . Tornado is a Python web framework and asynchronous networking library using nonblocking network I/O. Its front end is implemented in Angular 43 and communicates with the back-end via a REST API.","refs":[{"start":64,"end":65,"marker":null,"target":"#foot_0"},{"start":210,"end":211,"marker":null,"target":"#foot_1"}]},{"text":"The back-end is implemented on top of madIS [2], a powerful extension of a relational DBMS with user-defined data processing functionality. MadIS is built on top of the SQLite API 4 .","refs":[{"start":44,"end":47,"marker":"bibr","target":"#b1"},{"start":180,"end":181,"marker":null,"target":"#foot_2"}]},{"text":"MadIS allows the creation of user-defined functions (UDFs) in Python and it uses them in the same way as its native SQL functions. Both Python and SQLite are executed in the same process, greatly reducing the communication cost between them. This is a major architectural element and has a positive impact on joint performance.","refs":[]},{"text":"MadIS is highly scalable, easily handling 10s of Gigabytes of data on a single machine. This benefit transparently carries over to distributed systems (e.g., Hadoop [3], Exareme [4]) which can use madIS in each node.","refs":[{"start":165,"end":168,"marker":"bibr","target":"#b2"},{"start":178,"end":181,"marker":"bibr","target":"#b3"}]},{"text":"In madIS, queries are expressed in madQL: a SQL-based declarative language extended with additional syntax and user-defined functions (UDFs). 5 One of the goals of madIS is to eliminate the effort of creating and using UDFs by making them first-class citizens in the query language itself. To allow easy UDF editing with a text editor, madIS loads the UDF source code from the file system. Whenever a UDF's source code changes, madIS automatically reloads the UDF definition. This allows rapid UDF development iterations, which are common in data exploration and experimentation.","refs":[{"start":142,"end":143,"marker":null,"target":"#foot_3"}]},{"text":"MadIS supports three types of UDFs:","refs":[]},{"text":"-Row functions: Programmable row functions work in a similar way as standard SQL row functions such as abs(), lower() and upper(). -Aggregate functions: Programmable aggregate functions work in a similar way as standard SQL aggregate functions such as sum(), min() and max(). -Virtual table functions: These are actually functions that take parameters and output table like data. They can be used in the SQL syntax wherever a regular table would be placed.","refs":[]},{"text":"All UDFs are written in Python and can use pre-existing Python libraries (NumPy6 , SciPy7 , etc.), thus inheriting features that are commonly used by data scientists [1].","refs":[{"start":79,"end":80,"marker":null,"target":"#foot_4"},{"start":88,"end":89,"marker":null,"target":"#foot_5"},{"start":166,"end":169,"marker":"bibr","target":"#b0"}]},{"text":"The expressiveness and the performance of madIS allow developers to implement fast data analysis and complex text mining tasks [5][6][7][8]. The above were compelling reasons for choosing it as our processing engine. The following is an example of an automatically produced query that text mines publications to extract links to research projects funded by the EC's seventh framework programme (FP7). The query preprocesses the text converting it to lower case and extracting its keywords, then joins the extracted keywords with the grants list and finally searches the context for positive words/phrases using pattern matching. ","refs":[{"start":127,"end":130,"marker":"bibr","target":"#b4"},{"start":130,"end":133,"marker":"bibr","target":"#b5"},{"start":133,"end":136,"marker":"bibr","target":"#b6"},{"start":136,"end":139,"marker":"bibr","target":null}]}]}],"tables":{},"abstract":{"title":"Abstract","paragraphs":[{"text":"A lot of work that has been done in the text mining field concerns the extraction of useful information from the full-text of publications. Such information may be links to projects, acknowledgements to communities, citations to software entities or datasets and more. Each category of entities, according to its special characteristics, requires different approaches. Thus it is not possible to build a generic mining platform that could text mine various publications to extract such info. Most of the time, a field expert is needed to supervise the mining procedure, decide the mining rules with the developer, and finally validate the results. This is an iterative procedure that requires a lot of communication among the experts and the developers, and thus is very time-consuming. In this paper, we present an interactive mining platform. Its purpose is to allow the experts to define the mining procedure, set/update the rules, validate the results, while the actual text mining code is produced automatically. This significantly reduces the communication among the developers and the experts and moreover allows the experts to experiment themselves using a userfriendly graphical interface.","refs":[]}]}}